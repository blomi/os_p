Design Document for Fuse RAID_1/RAID_5 Systems
==========================================

##MEMBERS:
*ბექა ლომიტაშვილი blomi11@freeuni.edu.ge

##Task 1: SERVER SIDE IMPLEMENTATION



Data structures and functions
========================


სერვერის მხარეს იმპლემენტირებული არის თითოეული ფუნქცია, რომელიც კლიენტის მხარეს პარამეტრად გადაეცემა ფიუზის ბიბლიოთეკას. როდესაც კლიენტის მხარეს დამაუნთებულ დირექტორიაში ხდება რომელიმე syscall-ის გამოძახება, რამოდენიმე გამონაკლისის გარდა, თითოეული მათგანი გადამისამართდება სერვერზე და სერვერი თავისთან არსებულ სთორიჯ დირექტორიაში შესაბამის syscall-ებს გამოიძახებს. 
ამ ფუნქციების გარდა, იმპლემენტირებულია რამოდენიმე ე.წ.  helper ფუნქციები. როგორებიცაა: 


int sendData(int connfd, char * data, int data_len);
ამ ფუნქციის დანიშნულება შემდეგია: გადმოცემული შეერთების ფაილ დესკრიპტორ connfd ში ჩაწეროს data buffer-იდან data_len რაოდენობის ბაიტები. დაბრუნებული მნიშვნელობა იქნება თუ რამდენი ბაიტის ჩაწერა მოახდინა. ფუნქციის აუცილებლობა არ ყოფილა. თუმცა საგრძნობლად ამარტივებს კოდს, რადგან თითოეული syscall-ის შესრულების შემდეგ, აუცილებელია კლიენტის მხარეს დავაბრუნოთ შესაბამისი ერრორ-კოდები, ხოლო ეს პროცედურა ძირითადად მსგავსია, შესაბამისად, ეს კოდის ბლოკი ემსახურება პრაქტიკულად ყველა syscall-ს

int readInt(int connfd);
ეს ფუნქცია სოკეტიდან კითხულობს 8 ბაიტის ზომის მონაცემს, კასტავს ინტად, და აბრუნებს მას. აუცილებელი ფუნქციაა იმ პროტოკოლის სამუშაოდ, რომელი პროტოკოლითაც ვაგზავნი კლიენტისგან სერვერისკენ და სერვერისგან კლიენტის მხარეს

int putInt(char * buffer, int num, int offset);
ეს ფუნქცია საპირისპიროა ზევით აღწერილი ფუნქციისა. სოკეტში წერს 8 ბაიტის ზომის მონაცემს.

დანარჩენი ფუნქციები არის მხოლოდ გზაგამტარი ფუნქციები. მათში ლოგიკა პრაქტიკულად არ არის იმპლემენტირებული. მათი მოვალეობაა გაარკვიონ თუ კლიენტის მხარეს რომელი syscall-ის გამოძახება მოხდა, და შემდეგ ანალოგიური syscall გამოიძახონ დისკზე არსებულ დატაზე. 

Algorithms
===========
s_write da s_read სისტემ ქოლებს, ჭირდებათ განუსაზღვრელი ზომის დატის გადაცემა სოკეტის მეშვეობით. მიუხედავად იმისა, რომ write და read სისქოლებს გადმოცემული ბუფერის ზომის ზედა ლიმიტი გააჩნიათ (თუ არ ვცდები 4096 ბაიტი), მაინც ვამჯობინე რომ პროგრამულად კიდევ დამენაწევრებინა ამ ბუფერის მონაცემები, და უფრო პატარ-პატარა ნაგლეჯებად გამეგზავნა სოკეტში, რათა არ ვყოფილიყავი დამოკიდებული ოპერაციული სისტემის მიერ დაწესებულ სტანდარტებზე. ამის მეშვეობით, ზუსტად ვიცი სერვერის მხარეს, თუ რა მაქსიმალური ზომის ბუფერის მიღება შეიძლება დამჭირდეს ერთბაშად.


Synchronization
===============
სერვერის მხარეს სინქრონიზაციის მექანიზმები არ დამჭირვებია, რადგან თითოეული სერვერი მხოლოდ ერთ კლიენტს ემსახურება, ხოლო კლიენტის მხარეს სინქრონიზაციის მექანიზმები გამოყენებულია, შესაბამისად კლიენტის მხრიდან ვუზრუნველყოფ რომ არ მოხდეს რამოდენიმე ნაკადით ერთდროულად ერთი და იგივე ბლოკზე წერა.


Rationale
=========
შესაძლებელი იყო სერვერის მხარეს მქონოდა გარკვეული ლოგიკა, რომელიც გაამარტივებდა კლიენტის შესასრულებელ სამუშაოს, თუმცა მივიჩნიე რომ ეს პრინციპულად არასწორი იქნებოდა ფაილური სისტემის თასქისთვის, რადგან სერვერის იმპლემენტაცია არ უნდა იყოს დამოკიდებული კლიენტის იმპლემენტაციაზე. 


##Task 1: CLIENT SIDE IMPLEMENTATION - RAID 1

Data structures and functions
========================
struct serv_addr{
	char * ip;
	int port;
};
სტრაქტი იმახოსვრებს კონკრეტული სერვერის იპ მისამართს და პორტს. ამ სტრაქტს იყენებს ქვემოთ აღწერილი სტრაქტი მაუნტი.


struct mount{
	char * diskname;
	char * mountpoint;
	int raid_id;
	struct serv_addr ** servers;
	int nServers;
	char * hotswap;
};

ამ სტრაქტში ინახება კონფიგ ფაილიდან წაკითხული მონაცემები.  diskname ში წერია მაუნთის სახელი. mountpoint ში წერია იმ ფოლდერის მისამართი, რომელსაც ამაუნტებს ფიუზ ლაიბრარი. raid_id-ის მნიშვნელობაები არის ან 5, ან 1, იმისდამიხედვით თუ რომელი ფაილსისტემის (RAID_5, RAID_1) მეშვეობით ხდება იმპლემენტაცია. servers არი ზემოთ აღწერილი სტრუქტურების მასივი, თითოეული სერვერის აიპის და პორტის გასაგებად. nServers არის სერვერების რაოდენობა. hotswap - ჰოტსვაპი 

putInt, readInt, sendData ფუნქციები ანალოგიურია სერვერზე არსებული ფუნქციებისა. ემსახურებიან პროტოკოლის მუშაობას, რომლითაც ხდება კლიენტ-სერვერ-ის კომუნიკაცია. 

int * getSockfd_arr(); ფუნქციის მეშვეობით, ფიუზის თითოეული გამოძახებული სისქოლი იღებს არსებულ სერვერებთან შეერთებების მონაცემებს(სოკეტების ფაილ დესკრიპტორების მასივი).  

int mark_down(int serv_index); ფუნქციის მეშვეობით, თითოეული ფუნქცია არეპორტებს პრობლემურ სოკეტს. ამ ფუნქციაში გადაწყდება შესაძლებელია თუ არა პროგრამის მუშაობის გაგრძელება, ჩავარდნილი სერვერების პირობებში. 

Algorithms
===========


Synchronization
===============
შემოტანილი მაქვს 1 ლოქი, რომელიც თითოეული syscall ის გამოძახებისას ილოქება, ხოლო მნიშვნელობის დაბრუნების წინ რილიზდება. ამ მექანიზმის საჭიროება გამოწვეულია იმ ფაქტით, რომ 1 კონკრეტულ სერვერთან კომუნიკაციისთვის, გამოიყენება 1 სოკეტი, ხოლო პროტოკოლის სამუშაოდ ამ სოკეტში ჩაწერისას, უკან პასუხს ელოდება კონკრეტული ბაიტების მიმდევრობას. პრობლემა იდგა მაშინ, როდესაც ერთი syscall-ის მუშაობის პროცესში, სხვა syscall იძახებოდა, უგზავნიდა სერვერს თავის მონაცემებს, ხოლო სერვერი ამ მონაცემებს აღიქვამდა თავდაპირველი syscall-ის კომუნიკაციად. ამ გაუგებრობას თავიდან იცილებს ეს ლოქი, რადგან როცა 1 syscall გამოძახებულია, შემდეგი გამოძახებები იბლოკება.

Rationale
=========


##Task 1: CLIENT SIDE IMPLEMENTATION - RAID 5

Data structures and functions
========================
int get_actual_size(int serv_index, int size);
სერვერისგან გეთატრის მიერ დაბრუნებული ზომა არ შეესაბამება სიმართლეს, რადგან ამ სერვერზე არსებულ ფაილში, ნაწილი ბიტებისა არის ე.წ. ფარითი ბიტები, რაც, ლოგიკურად არ ასახავს სერვერის დატას. ეს ფუნქცია მოცემული ზომისთვის დათვლის თუ რამდენი ფარითის ბიტი არის ზედმეტობით შეყვანილი მასში, და დააბრუნებს ზუსტ მნიშვნელობას თუ რამხელაა ფაილი.

int myxor(char * c1, const char * c2, int len);
სავარაუდოდ არსებობს ბიბლიოთეკა რომელიც ორ მასივს ერთმანეთთან ქსორავს, თუმცა მე მაინც ჩემი დავწერე. პირველ მასივში წერს პირველი და მეორე მასივების შესაბამისი ბიტების ქსორს.

int write_block(const char * buffer, int serv_index, int sockfd, int stripe, int path_len, const char * path, int fd, int num_bytes, int b_offset, int r_offset);
ეს ფუნქცია გადაცემულ serv_index სევერზე sockfd დესკრიპტორში წერს buffer ბუფერის  r_offset-ოფსეტიდან  num_bytes-ზომის მონაცემს. ხოლო აბრუნებს მნიშვნელობას თუ რამდენი ბაიტის ჩაწერა მოხერხდა. დაბრუნებული -1 პრობლემის მანიშნებელია. ან სერვერია ჩავარდნილი, ან ფუნქციამ დააბრუნა errno კოდი

int read_block(char * block, int serv_index, int sockfd, int stripe, int path_len, const char * path, int fd, int num_bytes, int b_offset);
ეს ფუნქცია გადაცემულ serv_index სევერზე sockfd დესკრიპტორიდან გადაწერს block ბუფერში  r_offset-ოფსეტიდან  num_bytes-ზომის მონაცემს. ხოლო აბრუნებს მნიშვნელობას თუ რამდენი ბაიტის წაკითხვა მოხერხდა. დაბრუნებული -1 პრობლემის მანიშნებელია. ან სერვერია ჩავარდნილი, ან ფუნქციამ დააბრუნა errno კოდი



int recover_block(char * block, int serv_index, int stripe, int path_len, const char * path, int fd, int num_bytes, int b_offset);
ეს ფუნქცია გამოიძახება მაშინ, როცა რომელიმე სერვერ ჩავარდნილია, და მისი მონაცემების აღდგენის საჭიროებაა სხვა სერვერების მეშვეობით.


Algorithms
===========
ფაილის დახლეჩვა BLOCK_SIZE ზომებად და შემდეგ შესაბამის სერვერებზე გადაგზავნა ხდება დავალების პირობაში აღწერილი წესით.  


Synchronization
===============


Rationale
=========



programis gamshvebi gashveba
=============
./net_raid_client /path/to/config/file -f -o nonempty
./net_raid_server ip port /path/to/storage/dir/